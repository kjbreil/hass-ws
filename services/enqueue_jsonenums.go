// Code generated by jsonenums -type=Enqueue; DO NOT EDIT.

package services

import (
	"encoding/json"
	"fmt"
)

var (
	_EnqueueNameToValue = map[string]Enqueue{
		"Enqueueadd":     Enqueueadd,
		"Enqueuenext":    Enqueuenext,
		"Enqueueplay":    Enqueueplay,
		"Enqueuereplace": Enqueuereplace,
	}

	_EnqueueValueToName = map[Enqueue]string{
		Enqueueadd:     "Enqueueadd",
		Enqueuenext:    "Enqueuenext",
		Enqueueplay:    "Enqueueplay",
		Enqueuereplace: "Enqueuereplace",
	}
)

func init() {
	var v Enqueue
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_EnqueueNameToValue = map[string]Enqueue{
			interface{}(Enqueueadd).(fmt.Stringer).String():     Enqueueadd,
			interface{}(Enqueuenext).(fmt.Stringer).String():    Enqueuenext,
			interface{}(Enqueueplay).(fmt.Stringer).String():    Enqueueplay,
			interface{}(Enqueuereplace).(fmt.Stringer).String(): Enqueuereplace,
		}
	}
}

// MarshalJSON is generated so Enqueue satisfies json.Marshaler.
func (r Enqueue) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _EnqueueValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Enqueue: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Enqueue satisfies json.Unmarshaler.
func (r *Enqueue) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Enqueue should be a string, got %s", data)
	}
	v, ok := _EnqueueNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Enqueue %q", s)
	}
	*r = v
	return nil
}
